# 置顶数据持久化测试指南

## 问题背景

Chrome 插件环境下，书签置顶状态会丢失，根因是**读-改-写竞态条件**。

## 修复方案

实现了**互斥锁机制**，确保同一时间只有一个存储写操作执行。

## 测试步骤

### 1. 基础置顶测试

1. 打开 Chrome 插件（`npm run dev:ext` 并加载到浏览器）
2. 添加 3 个测试书签：
   - A: https://www.google.com
   - B: https://www.github.com
   - C: https://www.stackoverflow.com
3. 点击书签 A 的"置顶"按钮
4. **立即**刷新插件页面（F5）
5. **预期结果**: 书签 A 仍然显示为置顶状态 ✅

### 2. 并发置顶测试（压力测试）

1. 快速连续点击多个书签的"置顶"按钮（间隔 < 100ms）：
   - 点击 A → 立即点击 B → 立即点击 C
2. 打开浏览器开发者工具（F12），查看 Console
3. **应该看到**: `[ChromeStorage] 写操作排队中... (队列位置: 2)` 等日志
4. 刷新页面
5. **预期结果**: A、B、C 都保持置顶状态 ✅

### 3. Chrome 同步冲突测试（重要！）

1. 置顶书签 A
2. 打开 Chrome 原生书签管理器（chrome://bookmarks）
3. 在书签栏中添加一个新书签
4. 回到插件，点击"同步 Chrome 书签"按钮
5. **预期结果**: 书签 A 仍然保持置顶状态 ✅
6. 再次刷新插件页面
7. **预期结果**: 书签 A 的置顶状态仍然保留（不会因为启动时自动同步而丢失）✅

### 4. 导入数据冲突测试

1. 置顶书签 A
2. 在另一个标签页操作插件（如添加书签 D）
3. 同时执行"导入数据"操作
4. 刷新页面
5. **预期结果**: 书签 A 的置顶状态不丢失 ✅

## 验证修复成功的标志

### 开发环境（`npm run dev:ext`）

打开浏览器 Console，看到以下日志说明互斥锁正在工作：

```
[ChromeStorage] 写操作排队中... (队列位置: 2)
[ChromeStorage] 写操作开始执行 (队列位置: 2)
```

### 生产环境

无日志输出，但置顶状态持久化正常。

## 同步机制说明

### 当前同步方式：手动触发

- ✅ **启动时**: 不自动同步书签数据（只读取分类结构）
- ✅ **手动同步**: 用户点击"同步 Chrome 书签"按钮
- ✅ **数据保护**: 同步时保留用户自定义字段（isPinned, pinnedAt, tags, description）

### 为什么移除了启动时的自动同步？

启动时自动同步会导致以下问题：

1. **启动变慢** - 同步可能阻塞初始化
2. **数据冲突** - 用户刚置顶书签后刷新，自动同步可能触发并发写入
3. **不必要的开销** - 大部分时候 Chrome 书签没变化

现在采用**手动同步**，用户完全控制同步时机。

## 技术细节

### 修复前（有竞态）

```
操作序列：
T1: 置顶A → saveBookmark(A) 读取旧数据 [A❌, B❌]
T2: 置顶B → saveBookmark(B) 读取旧数据 [A❌, B❌]
T3: saveBookmark(A) 写入 [A✅, B❌]
T4: saveBookmark(B) 写入 [A❌, B✅] ← 覆盖！

结果：A 的置顶状态丢失
```

### 修复后（有互斥锁）

```
操作序列：
T1: 置顶A → 获取锁 → saveBookmark(A) 读取 [A❌, B❌]
T2: 置顶B → 等待锁...
T3: saveBookmark(A) 写入 [A✅, B❌] → 释放锁
T4: 置顶B → 获取锁 → saveBookmark(B) 读取 [A✅, B❌]
T5: saveBookmark(B) 写入 [A✅, B✅] → 释放锁

结果：A 和 B 的置顶状态都保留 ✅
```

## 如果问题仍然存在

1. 确保使用的是最新代码（已包含互斥锁）
2. 清除 Chrome Storage 数据后重新测试：
   ```javascript
   // 在插件的 Console 中执行
   chrome.storage.local.clear()
   ```
3. 提供以下信息：
   - 操作步骤录屏
   - Console 日志截图
   - Chrome 版本号
